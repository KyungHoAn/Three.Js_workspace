<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <link rel="stylesheet" href="./vaz.css">
    <title>Three.js - Fundamentals with light</title>
  </head>
<body>
    <script type="importmap">
        {
            "imports" : {
                "three" : "../build/three.module.js",
                "OrbitControls" : "./jsm/controls/OrbitControls.js",
                "three/examples/jsm/libs/stats.module": "../examples/jsm/libs/stats.module.js",
                "OBJLoader" :"./jsm/loaders/OBJLoader.js",
                "GLTFLoader":"./jsm/loaders/GLTFLoader.js",
                "GUI":"./jsm/libs/lil-gui.module.min.js",
                "MTLLoader":"./jsm/loaders/MTLLoader.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three'
        import { OrbitControls } from 'OrbitControls'
        import { GUI } from 'GUI'
        import { OBJLoader } from 'OBJLoader'
        import {MTLLoader} from 'MTLLoader'
        import {GLTFLoader} from 'GLTFLoader'

        const scene = new THREE.Scene()
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000)
        const TRAY = document.getElementById('js-tray-slide')

        const canvas = document.querySelector('#c')
        const clock = new THREE.Clock()
        const gui = new GUI()

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true })
        let autoE = false
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.shadowMap.enabled = true
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.shadowMap.type = THREE.PCFSoftShadowMap
        document.body.appendChild(renderer.domElement)

        const controls = new OrbitControls(camera, renderer.domElement)
        function setCamera() {
            camera.position.set(-15,5,17)
            controls.enableDamping = true
            controls.maxDistance = 2
            controls.update()
        }
        setCamera()
        let loader = new GLTFLoader()

        const burger = await loader.loadAsync('./burger/scene.gltf')
        const burger2 = await loader.loadAsync('./burger/scene.gltf')
        const burger3 = await loader.loadAsync('./burger/scene.gltf')
        let theModel = burger.scene
        let goldModel = burger2.scene
        let matModel = burger3.scene
        scene.add(theModel)

        theModel.traverse((o) => {
            if(o.isMesh) {
                o.castShadow = true
                o.receiveShadow = true
            }
        })

        let ambientLight = new THREE.AmbientLight(0xffffff, 1)
        scene.add(ambientLight)
        // let hemiLight = new THREE.HemisphereLight(0xffffff,0xffffff,0.61)
        // hemiLight.position.set(0,50,0)
        // scene.add(hemiLight)

        const background_color = 0x787878
        scene.background = new THREE.Color(background_color)
        scene.fog = new THREE.Fog(background_color,20,100)

        const colors = [{color:'FFFFFF'},{color:'0C0C0C'},{color:'C5C5C5'},{color:'FF0000'},{color:'0052FF'},{color:'1EFF00'},{color:'E9ED11'}]
        function buildColors(colors) {
            for(let [i, color] of colors.entries()) {
                let swatch = document.createElement('div')
                swatch.classList.add('tray__swatch')
                swatch.style.background = "#" +color.color
                swatch.setAttribute('data-key',i)
                TRAY.append(swatch)
            }
        }
        buildColors(colors)

        const swatches = document.querySelectorAll('.tray__swatch')
        for(const swatch of swatches) {
            swatch.addEventListener('click', selectSwatch)
        }

        function selectSwatch(e) {
            let color = colors[parseInt(e.target.dataset.key)]
            let new_mtl
            new_mtl = new THREE.MeshPhongMaterial({
                color:parseInt('0x'+color.color),
                shininess: color.shininess?color.shininess: 10
            })
            setMterialColor(theModel, new_mtl)
        }

        function setMterialColor(parent, mtl) {
            parent.traverse(function(child) {
                    if(child.isMesh) {
                        if(mtl.color.r == 1 && mtl.color.g == 1 && mtl.color.b == 1){
                            // console.log(child.children[0])
                            child.remove(child.children[0])     // wireframe
                        } else {
                            let wireframeGeometry = new THREE.WireframeGeometry(child.geometry)
                            let wireframeMaterial = new THREE.LineBasicMaterial({color:mtl.color})
                            let wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial)
                            child.add(wireframe)
                    }
                }
            })
        }
        
        let props = {}
        const renderFolder = gui.addFolder("RENDER")
        props.finalButton = function() {
            baseFunc()
        }
        let FinalBtn = renderFolder.add(props, 'finalButton').name('Final Render')

        const materialFolder = gui.addFolder("Emission")
        // basic color
        props.baseButton = function() {
            baseFunc()
            theModel.traverse(function(child) {
                if(child.isMesh) {
                    child.material.color.r = 1
                    child.material.color.g = 1
                    child.material.color.b = 1
                }
            })
        }
        let baseBtn = materialFolder.add(props, 'baseButton').name('Base Color')

        // 빛 x
        props.emissionButton = function() {
            baseFunc()
            theModel.traverse(function(child) {
                if(child.isMesh) {
                    child.material.color.r = 0
                    child.material.color.g = 0
                    child.material.color.b = 0
                }
            })
        }
        let emissionBtn = materialFolder.add(props,'emissionButton').name('Emission')

        const geometryFolder = gui.addFolder("GEOMETRY")
        // 금속
        props.matcapButton = function() {
            if(scene.name == '' || scene.name == 'mat') {
                scene.remove(theModel)
                scene.remove(matModel)
                scene.add(goldModel)
                scene.name = 'burger'
            }
            const matcapTexture = new THREE.TextureLoader().load('./burger/matcap-gold.png')
            goldModel.traverse(function(child) {
                if(child.isMesh) {
                    child.material.map = matcapTexture
                }
            })
        }
        let matcapBtn = geometryFolder.add(props,'matcapButton').name('Matcap')

        // wireframe
        props.wireFrameButton = function() {
            if(scene.name == 'burger' || scene.name == '') {
                scene.remove(goldModel)
                scene.add(matModel)
                scene.name = 'mat'
            }
            matModel.traverse(function(child) {
                if(child.isMesh) {
                    if(child.children == '') {
                        let wireframeGeometry = new THREE.WireframeGeometry(child.geometry)
                        let wireframeMaterial = new THREE.LineBasicMaterial({color:0xffffff})
                        let wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial)
                        child.add(wireframe)
                        let matcapMaterial = new THREE.MeshMatcapMaterial()
                        child.material = matcapMaterial
                    }
                }
            })
        }
        let wireFrameBtn = geometryFolder.add(props,'wireFrameButton').name('Wireframe')

        function baseFunc() {
            if(scene.name == 'burger' || scene.name == 'mat'){
                scene.remove(goldModel)
                scene.remove(matModel)
                scene.add(theModel)
                scene.name = ''
            }
        }

        function animate() {
            requestAnimationFrame(animate)
            renderer.render(scene,camera)
        }
        animate()

        function onWindowReSize() {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
        }
        window.addEventListener('resize',onWindowReSize)

    </script>
    <canvas id="c"></canvas>
    <div class="controls">
        <div id="js-tray" class="tray">
            <div id="js-tray-slide" class="tray__slide"></div>
        </div>
    </div>
</body>
</html>